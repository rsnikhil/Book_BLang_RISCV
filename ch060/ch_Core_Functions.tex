% -*- mode: fundamental -*-

% ****************************************************************

\chapter{RISC-V: Core functions for RISC-V ISA execution}

\markboth{Ch \arabic{chapter}: Core functions}{\copyrightnotice}

\setcounter{page}{1}
% \renewcommand{\thepage}{\arabic{page}}
\renewcommand{\thepage}{\arabic{chapter}-\arabic{page}}

\label{ch_core_functions}

% ****************************************************************

\section{Introduction}

In this chapter we discuss the core functions of
Figure~\ref{Fig_Simple_Instr_Exec_w_structs}.
\begin{figure}[htbp]
  \centerline{\includegraphics[width=6in,angle=0]{ch030_RISCV_Design_Space/Figures/Fig_Instr_Exec_w_structs}}
  \caption{\label{Fig_Fetch_function_Simple_Instr_Exec}
           Simple interpretation of RISC-V instructions}
\end{figure}

% ****************************************************************

\section{The Fetch function}

\label{Sec_Fetch_function}

\index{fn\_Fetch@{\tt fn\_Fetch} (Fetch function)}
\index{Fetch function ({\tt fn\_Fetch})}

The Fetch function \emph{per se} is fairly simple, even trivial.  Its
input is the current value of the program counter (PC), which is used
as the address in a memory-request to IMem.  It has two outputs,

\begin{tightlist}

 \item A \emph{memory request} to memory, to read an instruction.  We
       have already seen the definitition of the \verb|Mem_Req| struct
       in Section~\ref{Sec_Mem_Req}.

 \item Some additional information ``\verb|F_to_D|'' passed on to the
       Decode step.

\end{tightlist}

The ``\verb|Fetch_to_Decode|'' struct has only one interesting field,
the PC:

\input{Code_Extracts/Fetch_to_Decode.tex}

The field \verb|inum| holds the ``instruction number'', which is a
sequence number counting every instruction fetched.  It is used only
for debugging, to be able to identify a specific fetched instruction.
(In the source code you will see two more fields \verb|predicted_pc|
and \verb|epoch|; ignore these for now, they are not used in Drum,
only in Fife.)

\index{BSV!struct!Nested}

To pass both results of \verb|fn_Fetch|, we simply use a \emph{nested}
struct, {\ie} a struct containing the two component structs:

\input{Code_Extracts/Result_F.tex}

Finally, as mentioned earlier, the function \verb|fn_Fetch| is almost
trivial:

\input{Code_Extracts/fn_Fetch.tex}

% ================================================================

\hdivider

% ----------------
\Exercise

Write a testbench for \verb|fn_Fetch()|, apply it to a number of
32-bit values (PC values) and print the results using \verb|$display|
and \verb|fshow|, and visually check that the \verb|F_to_D| and
\verb|Mem_Req| outputs look correct.

\Endexercise

% ****************************************************************

\section{The Decode function}

\label{Sec_Decode_Function}

\index{fn\_Decode@{\tt fn\_Decode} (Decode function)}
\index{Decode function ({\tt fn\_Decode})}

The core function for the Decode step is called \verb|fn_Decode|.
It's arguments are an \verb|Fetch_to_Decode| struct from the Fetch
step and a \verb|Mem_Rsp| memory response struct from memory.  Its
output struct type, \verb|Decode_to_RR|, was described in
Section~\ref{Sec_struct_D_to_RR}.  The code for \verb|fn_Decode| is
mostly a big if-then-else that analyses the incoming instruction and
produces some summary information:

\input{Code_Extracts/fn_Decode.tex}

\index{truncate@{\tt truncate}, operation to shrink bit-width}

In line 6, we extract the instruction from the \verb|Mem_Rsp| memory
response data from the Fetch operation, The \verb|truncate| operation
is used to shrink the bit-vector width of \verb|rsp_IMem.data| (64
bits) to the bit-vector width of \verb|instr| (32 bits).
(Section~\ref{Sec_Mem_Req} discussed why we declared
\verb|rsp_IMem.data| to be 64-bits wide).  The \verb|truncate|
operation is polymorphic, accepting arguments of any bit-width that is
at least as wide as the required output.  Note, \verb|truncate| keeps
least-significant bits and drops most-significant bits.

In line 7 we extract the \verb|rd| (``destination register'') field
from the instruction.  In line 9 we compute the fall-through PC, PC+4
(with the caveat that if we want to support the ``C'' RISC-V ISA
extension (``Compressed'' instructions), it may be PC+2, which
information can be gleaned from the instruction encoding).

In lines 11-26 we create a baseline \verb|Decode_to_RR| value which we
will selectively modify in the if-then-else statements that follow.

In lines 31-40 we first handle the sitations where the Fetch operation
to memory itself returned an error.  We mark the \verb|exception|
field True and fill in the appropriate \verb|cause| and \verb|tval|
(these will be placed in MCAUSE and MTVAL CSRs in the Retire step).

The rest of the code is a series of if-then-else clauses. Each clause
identifies one class of instruction and updates the \verb|opclass|
field correspondingly.  The repertoire of instructions that we
consider are the forty instructions listed in the ``RV32I Base
Instruction Set'' table of ``Table 24.2: Instruction listing for
RISC-V'' of the Unprivileged Spec~\cite{RISCV_Unpriv_2019_12_13}.

Each if-then-else clause also fills in the \verb|has_rs1|,
\verb|has_rs2| and \verb|has_rd| fields, as appropriate, for each
class of instruction.  Note that the \verb|has_rd| field is set to
False if \verb|rd| is zero (recall that general-purpose register
\verb|x0| ignores writes and always reads as 0).

We also decode each kind of ``immediate'' and fill in the \verb|imm|
field in the struct.  Recall from
Section~\ref{Sec_Instruction_Encodings}, including
Figures~\ref{Fig_J_imm} and \ref{Fig_B_imm}, that different classes of
instructions encode immediate values in different ways, and the
immediate values can have different bit-widths.  We use the functions
\verb|instr_imm_I()|, \verb|instr_imm_S()|, \verb|instr_imm_B()|,
\verb|instr_imm_U()| and \verb|instr_imm_J()| to extract the and
rearrange the immediate bits appropriately for each class of
instruction.  Then, here in \verb|fn_Decode|, we zero- or sign-extend
each immediate as appropriate so that, from this point onwards, each
immediate can be treated as an ordinary \verb|Bit#(XLEN)| value.

An exercise below suggests that you write the code for these
\verb|instr_imm_X| functions; it's good practice for the BSV beginner!

The final ``else'' clause is selected if the instruction does not
match any of the forty RV32I instructions.  In this case we set the
\verb|exception| field, and set the \verb|cause| field to indicate an
illegal instruction.

Observe that the entire \verb|fn_Decode()| function is just a (large)
combinational circuit---it is an acyclic composition of smaller
combinational circuits, many of which we've seen earlier.  The whole
\verb|fn_Decode()| function can be visualized as a box with incoming
wires corresponding to the \verb|Fetch_to_Decode| struct and the
\verb|Mem_Rsp| struct, outgoing wires corresponding to the
\verb|Decode_to_RR| struct, and filled with logic gates that compute
each output wire as a function of the input wires.

% ================================================================

\hdivider

% ----------------
\Exercise

The provided source code includes the functions \verb|instr_imm_I()|,
\verb|instr_imm_S()|, \verb|instr_imm_B()|, \verb|instr_imm_U()| and
\verb|instr_imm_J()| (in file \verb|Instr_Bits.bsv|), but try to write
them yourself first, and compare your solutions to the provided codes.

% ----------------
\Exercise

Write a testbench for \verb|fn_Decode()|, apply it to a number of PC
and instruction values.  For each input PC value, construct an
\verb|Fetch_to_Decode| struct around it.  For each input instruction,
construct a \verb|Mem_Rsp| struct around it, some with memory errors,
some without.  Apply \verb|fn_Decode| to such pairs.  Print the
results results using \verb|$display| and \verb|fshow|, and visually
check that the \verb|D_to_RR| outputs look correct.

\Endexercise

% ****************************************************************

\section{The Dispatch function following Register-Read}

\label{Sec_Dispatch_function}

\index{fn\_Dispatch@{\tt fn\_Dispatch} (Dispatch function)}
\index{Dispatch function ({\tt fn\_Dispatch})}

In the Register-Read and Dispatch step (``RR''), we first read the
\verb|rs1| and \verb|rs2| values from the Register File.  We will
cover register files in Section~\ref{Sec_Register_files}, and
register-reads when we discuss the Drum CPU itself, in
Chapter~\ref{ch_Drum_code}.

With the \verb|rs1| and \verb|rs2| values, we use function
\verb|fn_Dispatch| to determine what needs to be passed to the various
alternative steps (``flows'') that follow.  Its argument is a
\verb|Decode_to_RR| struct from the Decode step, which was discussed
in Section~\ref{Sec_struct_D_to_RR}.  Before we look at the result
type of \verb|fn_Dispatch|, let us look at the four possible flows in
the subsequent steps:

\begin{itemize}

  \item ``Direct'': Some information is sent directly from RR to
        Retire for \emph{every} instruction.  Crucially, RR sends a
        \emph{tag} that indicates which of the four flows is being
        followed for the current instruction.

        Additional direct information includes information from RR
        (PC, whether an exception has already been seen in the Fetch
        or Decode stages, \verb|has_rd|, \verb|writes_mem|, the
        instruction, the fall-through PC and the \verb|rs1| value
        (needed for CSRRx instructions).

       The direct flow is also used for all SYSTEM instructions,
       including CSRRxx, ECALL, EBREAK, and MRET.

  \item ``Control'': If the instruction is a BRANCH, JAL or JALR, we
        produce information for the Execute Control flow.

  \item ``Integer'': If the instruction is a LUI, AUIPC or integer
        arithmetic or logic (IALU) operation, we produce information
        for the Execute Integer flow.

  \item ``DMem'': If the instruction is a LOAD, STORE or FENCE, we
        produce information for the Execute Memory flow.

\end{itemize}

The following enum type declaration defines four constants to identify
the flow for this instruction:

\input{Code_Extracts/Exec_Tag.tex}

The result type of \verb|fn_Dispatch| is \verb|Result_Dispatch|.  It
is just a nested struct that contains four different struct types for
the four flows (the struct types are labeled in
Figure~\ref{Fig_Drum_Instr_Exec}).

\input{Code_Extracts/Result_Dispatch.tex}

The direct information is defined in the type \verb|RR_to_Retire|:

\input{Code_Extracts/RR_to_Retire.tex}

The \verb|exec_tag| informs Retire about the flow for this
instruction.  The {\tt exception} and {\tt cause} fields from
\verb|Decode_to_RR| are carried through, as-is, since it is the Retire
step that handles all exceptions.  Note, in addition to passing
exceptions from RR to Retire, the Control or Execute steps could also
raise exceptions.  The {\tt pc} field is needed in case Retire needs
to handle a trap or interrupt, which saves the {\tt pc} before
handling it.

The \verb|has_rd| and \verb|rd| fields are carried through to control
whether Retire tries to write a value back to the register file nor
not.  The \verb|fallthru_pc| is used for most instructions that
complete successfully (without raising an exception).

Returning our attention to the \verb|Result_Dispatch| struct type, the
second component, of type \verb|RR_to_Control| and used for the
Control flow, was described in Section~\ref{Sec_Control_function}. The
third component, of type \verb|RR_to_EX| and used in the Integer flow,
was described in Section~\ref{Sec_EXI_function}.  The fourth
component, of type \verb|Mem_Req| and used in the DMem flow, was
described in Section~\ref{Sec_Mem_Req}.

The code for \verb|fn_Dispatch| is shown below.  Its arguments are the
\verb|Decode_to_RR| struct from the Decode stage, and values from the
source registers \verb|rs1| and \verb|rs2|.

\input{Code_Extracts/fn_Dispatch.tex}

Lines 7-14 compute \verb|exec_tag|, {\ie} the flow to be followed.



Lines 13-20 compute the \verb|exec_tag| based on the kind of
insrruction.

Lines 16-29, 33-38, 42-46 and 49-61 construct the flow-specific struct
values.  The latter three are meaningful only if \verb|exec_tag|
indicates Control, Integer of DMem, respectively, but we can construct
them anyway; they will only be used if those flows are chosen.

Lines 64-68 construct the final result and return it.

% ****************************************************************

\section{The Execute Control function}

\label{Sec_Control_function}

\index{fn\_Control@{\tt fn\_Control} (Execute Control function)}
\index{Execute Control function ({\tt fn\_Control})}

We will next discuss the ``execute'' functions (Control, IALU and
DMem), which can also be characterized as pure value-to-value
functions.

The input and output of \verb|fn_Control|, the Control function in
Figure~\ref{Fig_Simple_Instr_Exec_w_structs}, are values of the
following types, respectively.  Each of the input fields is needed to
compute one or more of the output fields.

{\small
\begin{Verbatim}[frame=single, numbers=left]
typedef struct {Bit #(XLEN)  pc;
		Bit #(XLEN)  fallthru_pc;
		Bit #(32)    instr;
		Bit #(XLEN)  rs1_val;
		Bit #(XLEN)  rs2_val;
		Bit #(32)    imm;
} RR_to_Control
deriving (Bits, Eq, FShow);

typedef struct {Bool         exception;
		Bit #(XLEN)  cause;        // Misaligned BRANCH/JAL/JALR target

		Bit #(XLEN)  next_pc;
		Bool         data_valid;    // True for JAL/JALR; False for BRANCH
		Bit #(XLEN)  data;          // Return-PC for JAL/JALR
} Control_to_Retire
deriving (Bits, FShow);
\end{Verbatim}
}

Here is the Control function \verb|fn_Control|:

{\small
\begin{Verbatim}[frame=single, numbers=left]
function Control_to_Retire fn_Control (RR_to_Control  x);
   let instr   = x.instr;
   let rs1_val = x.rs1_val;
   let rs2_val = x.rs2_val;

   Bit #(XLEN)  next_pc   = ?;
   Bool         exception = False;    // Misaligned target_pc

   if (is_BRANCH (instr)) begin
      Bool branch_taken = case (instr_funct3 (instr))
                             funct3_BEQ:  (rs1_val == rs2_val);
                             funct3_BNE:  (rs1_val != rs2_val);
                             funct3_BLT:  signedLT (rs1_val, rs2_val);
                             funct3_BGE:  signedGE (rs1_val, rs2_val);
                             funct3_BLTU: (rs1_val < rs2_val);
                             funct3_BGEU: (rs1_val >= rs2_val);
                          endcase;
      Bit #(13) imm13 = x.imm [12:0];
      let target_pc = x.pc + signExtend (imm13);
      next_pc = (branch_taken ? target_pc : x.fallthru_pc);
      exception = (branch_taken && (target_pc [1:0] != 0));
   end
   else if (is_JAL (instr)) begin
      Bit #(21) imm21 = x.imm [20:0];
      next_pc = x.pc + signExtend (imm21);
      exception = (next_pc [1:0] != 0);
   end
   else if (is_JALR (instr)) begin
      Bit #(12) imm12 = x.imm [11:0];
      // zero out LSB in target PC
      next_pc = ((rs1_val + signExtend (imm12)) & ~1);
      exception = (next_pc [1:0] != 0);
   end

   Bool data_valid = ((instr_rd  (instr) != 0)
                      && (is_JAL (instr) || is_JALR (instr)));
   let y = Control_to_Retire {inum:       x.inum,
                              pc:         x.pc,
                              instr:      x.instr,
                              exception:  exception,
                              cause:      cause_INSTRUCTION_ADDRESS_MISALIGNED,
                              next_pc:    next_pc,
                              data_valid: data_valid,
                              data:       x.fallthru_pc};
   return y;
endfunction
\end{Verbatim}
}

Lines 9-22 handle BRANCH (conditional branch) instructions.  First the
\verb|case| expression computes the boolean value \verb|branch_taken|,
the decision whether to take the branch or not.  This is based on the
3-bit \verb|funct3| field of the instruction that identifies the
specific condition to be tested.  Note that for BLT and BGE, we use
the \verb|signedLT| and \verb|signedGE| functions that interpret
\verb|rs1_val| and \verb|rs2_val| as signed integers.

Line 19 computes the target PC should the the branch be taken.  Line
20 computes the next PC, which is either the target PC or the
fall-through PC depending on whether the branch is taken or not.
Finally, Line 21 checkes that if the branch is taken, that the target
PC is a suitably aligned address.

Lines 23-27 handle JAL (Jump and Link) instructions, and lines 28-33
handle the JALR (Jump and Link Register) instructions.  They are both
straightforward, unconditional calculations of a next PC, along with
an alignment-check that the next PC is suitably aligned.

Notice that the nested if-then-else has no final ``else'' clause.
This is safe because of the checks already done in the Decode function
\verb|Fn_D|, which guarantee that this function will only be invoked
with inputs that are handled by one of the three clauses.

Finally, lines 35 through 45 construct the final result and return it.

\vspace*{2ex}

NOTE:
\fbox{\small
\begin{minipage}{5in}

{\bf RISC-V: misaligned branch/jump targets}

\vspace{1ex}

In {\tt fn\_Control}, the BRANCH, JAL and JALR clauses set the
{\tt exception} field to true if the next PC is not aligned.  This is
required by the RISC-V Spec (see ``Section 2.5 Control Transfer
Instructions'' in \cite{RISCV_Unpriv_2019_12_13}).  If there is a
misalignment error, we encounter it here on the control-transfer
instruction.

\vspace{1ex}

If we do not check alignment here, we will encounter a misalignment
error on the next Fetch, at the next-PC address.  The choice of
catching this earlier, at the control-transfer instruction itself, is
a design choice by the RISC-V ISA architects.

\end{minipage}}

\vspace*{2ex}

\hdivider

% ----------------
\Exercise

Prove (informally) that the three-way if-then-else in
\verb|Fn_Control| will catch all cases, {\ie} that we never need a
final ``else'' clause.  This requires reviewing the Decode function
\verb|fn_Decode|, and tracking the flow of information through the
Register-Read-and-Dispatch step (including the Dispatch function
\verb|fn_Dispatch)| into \verb|fn_Control|.

% ----------------
\Exercise

In \verb|Fn_Control|, can we change the final ``if'' condition line:

{\small
\begin{Verbatim}[frame=single]
   else if (is_JALR (instr)) begin
\end{Verbatim}
}

into a simple ``else'' clause ({\ie} omit the the \verb|is_JALR| check)?

{\small
\begin{Verbatim}[frame=single]
   else begin
\end{Verbatim}
}

What might be the hardware implication of such a change?

% ----------------
\Exercise

In line 35 in {\tt fn\_Control}, we are testing {\tt (instr\_rd
(instr) != 0)}.  But we tested this in computing the boolean {\tt
has\_rd} in {\tt fn\_Decode}, the Decode function.  Discuss the hardware
tradeoffs in just passing that boolean value along in the structs to
this point, instead of recomputing it here.

\Endexercise

% ****************************************************************

\section{The Execute Integer Ops function}

\label{Sec_EXI_function}

\index{fn\_EX\_IALU@{\tt fn\_IALU} (Execute Integer Ops function)}
\index{Execute Integer Ops function ({\tt fn\_EX\_IALU})}

The input and output of \verb|fn_EX_IALU|, the ``Execute Integer Ops''
function in Figure~\ref{Fig_Simple_Instr_Exec_w_structs}, are values
of the following types, respectively.  Each of the input fields is
needed to compute one or more of the output fields.

{\small
\begin{Verbatim}[frame=single, numbers=left]
typedef struct {Bit #(XLEN)  pc;
		Bit #(32)    instr;
		Bit #(XLEN)  rs1_val;
		Bit #(XLEN)  rs2_val;
		Bit #(32)    imm;
} RR_to_EX
deriving (Bits, FShow);

typedef struct {Bool         exception;
		Bit #(XLEN)  cause;

		Bool         data_valid;
		Bit #(XLEN)  data;
} EX_to_Retire
deriving (Bits, FShow);
\end{Verbatim}
}

Here is the Execute Integer Ops function \verb|fn_EX_IALU|:

{\small
\begin{Verbatim}[frame=single, numbers=left]
function EX_to_Retire fn_EX_IALU (RR_to_EX x);
   let instr = x.instr;

   let y = EX_to_Retire {inum:       x.inum,
                         pc:         x.pc,
                         instr:      instr,
                         exception:  False,
                         cause:      ?,
                         data_valid: True,
                         data:       ?};

   if (is_LUI (instr))
      y.data = (zeroExtend (instr_imm_U (instr)) << 12);
   else if (is_AUIPC (instr)) begin
      Bit #(XLEN) offset = signExtend ({ instr_imm_U (instr), 12'b0 });
      y.data = x.pc + offset;
   end
   else begin
      let result <- fn_IALU (logf, instr, x.rs1_val, x.rs2_val, x.imm);
      y.data = result;
   end
   return y;
endfunction
\end{Verbatim}
}

Lines 12-13 handle LUI instructions (Load Upper Immediate).  Lines
14-17 handle AUIPC instructions (Add Upper Immediate to PC).  Lines
18-21 invoke {\tt fn\_IALU} to perform all the remaining Integer ops,
and this is shown in the code below.

{\small
\begin{Verbatim}[frame=single, numbers=left]
function Bit #(XLEN) fn_IALU (Bit #(32)    instr,
                              Bit #(XLEN)  v1,
                              Bit #(XLEN)  v2,
                              Bit #(32)    imm);
   Bit #(7)    opcode = instr_opcode (instr);
   Bit #(3)    funct3 = instr_funct3 (instr);
   Int #(XLEN) iv1    = unpack (v1);
   Int #(XLEN) iv2    = unpack (v2);
   Int #(XLEN) i_imm  = unpack (signExtend (instr_imm_I (instr)));

   Bit #(XLEN) y_OP     = 0;
   if (opcode == opcode_OP) begin
      Bit #(5) shamt = v2 [4:0];
      case (funct3)
         funct3_ADD:  y_OP = pack ((instr [30] == 1'b0)
	                           ? (iv1 + iv2)
				   : (iv1 - iv2));
         funct3_SLL:  y_OP = v1 << shamt;
         funct3_SLT:  y_OP = ((iv1 < iv2) ? 1 : 0);
         funct3_SLTU: y_OP = ((v1  < v2)  ? 1 : 0);
         funct3_XOR:  y_OP = v1 ^ v2;
         funct3_SRL:  y_OP = v1 >> shamt;
         funct3_SRA:  y_OP = pack (iv1 >> shamt);
         funct3_OR:   y_OP = v1 | v2;
         funct3_AND:  y_OP = v1 & v2;
      endcase
   end

   Bit #(XLEN) y_OP_IMM = 0;
   if (opcode == opcode_OP_IMM) begin
      Bit #(5) shamt = imm [4:0];
      case (funct3)
         funct3_ADDI:  y_OP_IMM = pack (iv1 + i_imm);
         funct3_SLTI:  y_OP_IMM = ((iv1 < i_imm) ? 1 : 0);
         funct3_SLTIU: y_OP_IMM = ((v1  < imm)   ? 1 : 0);
         funct3_XORI:  y_OP_IMM = v1 ^ imm;
         funct3_ORI:   y_OP_IMM = v1 | imm;
         funct3_ANDI:  y_OP_IMM = v1 & imm;
         funct3_SLLI:  y_OP_IMM = v1 << shamt;
         funct3_SRLI:  y_OP_IMM = v1 >> shamt;
         funct3_SRAI:  y_OP_IMM = pack (iv1 >> shamt);
      endcase
   end

   return (y_OP | y_OP_IMM);
endfunction
\end{Verbatim}
}

In lines 7-8, we define signed-integer versions {\tt iv1}, {\tt iv2}
of the unsigned integer values {\tt v1} and {\tt v2}, respectively.
There is no hardware cost to this definition, it's simply a
declaration to ``view'' the same bits differently (as 2's-complement
coded integers).  The difference arises later, when we apply certain
operators to these values.  For example, lines 19-20 compute the SLT
(Set Less Than (signed)) and SLTU (Set Less Than Unsigned) operations.
The SLT op uses the signed values {\tt iv1} and {\tt iv2}, whereas
SLTU uses the unsigned values {\tt v1} and {\v2}.  Between the
\emph{bsc} compiler and the Verilog back-end, different code will be
generated for the ``{\tt <}'' operator to perform the correct kind of
comparison.

Line 13 extracts a 5-bit ``shift amount'' from the {\tt rs2} value for
the shift operators SLL, SRL and SRA.  Line 31 extract a 5-bit ``shift
amount'' from the {\tt imm} value for the shift operators SLLI, SRLI
and SRAI.  SRL (Shift Right Logical) and SRA (Shift Right Arithmetic)
differ in whether they treat the argument as a signed or unsigned
value, the difference being whether the new bits shifted in at the
most-significant bit side are zero (SRL) or replicate the
most-significant bit (SRA).  SRLI and SRAI exhibit a similar
difference.

In lines 23 (SRA) and 41 (SRAI) we finally apply the ``{\tt pack}''
operator to produce the result. This is because the expression
``\verb|(iv1 >> shamt)|'' has type {\tt Int\#(XLEN)} whereas the
result needs to be of type {\tt Bit\#(XLEN)}.  The ``{\tt pack}''
operator performs this type-change for us.

Lines 11-27 define the {\tt y\_OP} result when the opcode is {\tt
opcode\_OP} {\ie} {\tt 7'b\_011\_0011}, {\ie} the ``3-address''
operators where the inputs come from {\tt rs1} and {\tt rs2}.
It defaults to 0 when it is not an {\tt op\_OP}.

Lines 29-43 define the {\tt y\_OP\_IMM} result when the opcode is {\tt
opcode\_OP\_IMM} {\ie} {\tt 7'b\_001\_0011}, {\ie} the ``2-address''
operators where one input come from {\tt rs1} and the other input
comes from an immediate value in the instruction.
It defaults to 0 when it is not an {\tt op\_OP\_IMM}.

Finally, line 45 combines these results using the ``OR'' function.  We
rely on the fact that exactly one of \verb|y_OP| and \verb|y_OP_IMM|
can be relevant; the other one must be zero (and therefore has no
effect through the OR'ing).

\hdivider

% ----------------
\Exercise

Lines 11-45 could instead have been written this way:

{\small
\begin{Verbatim}[frame=single, numbers=left]
   Bit #(XLEN) y = 0;
   if (opcode == opcode_OP) begin
      ...
      ... y = ...
   end
   else if (opcode == opcode_OP_IMM) begin
      ...
      ... y = ...
   end
   return y;
\end{Verbatim}
}

Discuss the hardware tradeoffs between writing it in these two ways.
{\emph Hints:} Consider:

\begin{tightlist}

  \item Sequentiality of if-then-else.
  \item Ability (or not) to prove exhaustiveness of conditions in nested if-then-else.
  \item Ability (or not) to prove mutual-exclusivity of conditions in nested if-then-else.
  \item Discussion in Section~\ref{Sec_MUXes} on parallel and
    sequential multiplexers (mux).  Note: in our code, we have
    explicitly coded a parallel mux.

\end{tightlist}

% ----------------
\Exercise

Note that the ISA has ADD and ADDI instructions, but no corresponding
SUB and SUBI (subtract) instructions.  Why not?

% ----------------
\Exercise

Justify the presence or absence of the ``{\tt pack}'' operator in each
case of {\tt fn\_IALU}.

% ----------------
\Exercise

Suppose we want to extend {\tt fn\_IALU} so it also works when XLEN=64
({\ie} for RV64I).  What needs to change to accommodate this?

\emph{Hint:} it only matters in the shift-amount of the shift
instructions, where the shift-amount can be 6-bits wide instead of
5-bits (allowing a maximum of 63-bit shifts instead of 31 bits).

\Endexercise

% ****************************************************************

\section{The Execute DMem function}

\label{Sec_DMem_function}

\index{fn\_DMem@{\tt fn\_DMem} (Execute DMem function)}
\index{Execute DMem function ({\tt fn\_DMem})}

The types of the input and output of the ``Execute Memory Ops''
function in Figure~\ref{Fig_Simple_Instr_Exec_w_structs} are the same
as for ``Execute Integer Ops'', {\ie} {\tt RR\_to\_EX} and {\tt
EX\_to\_Retire}, which were described in Section~\ref{Sec_EXI_function}.

Figure~\ref{Fig_fn_DMem} shows that the ``Execute Memory Ops''
function can be split into two phases,
\begin{figure}[htbp]
  \centerline{\includegraphics[width=6in,angle=0]{ch060/Figures/Fig_fn_DMem}}
  \caption{\label{Fig_fn_DMem}The Execute Memory Ops function is split into two phases.}
\end{figure}
just like we did for Fetch.  The first phase generates a memory
request, and the second phase processes the memory response.  As with
Fetch, there is no guarantee how ``soon'' the response will come.

Here is the function for the first phase, computing a memory request:

{\small
\begin{Verbatim}[frame=single, numbers=left]
function Mem_Req fn_DMem_Req (RR_to_EX  x);
   Bool is_LD = is_LOAD  (x.instr);
   Bool is_ST = is_STORE (x.instr);

   // Mem effective-address calculation
   Int #(XLEN) ibase   = unpack (x.rs1_val);                  // Signed
   Int #(XLEN) ioffset = unpack (signExtend (x.imm [11:0]));  // Signed
   Bit #(XLEN) eaddr   = pack (ibase + ioffset);

   Mem_Req_Size mrq_size = unpack (x.instr [13:12]);  // B, H, W or D
   Mem_Req_Type mrq_type = (is_LD ? funct5_LOAD : funct5_STORE);

   let y = Mem_Req {inum:     x.inum,
                    pc:       x.pc,
                    instr:    x.instr,
                    req_type: mrq_type,
                    size:     mrq_size,
                    addr:     zeroExtend (eaddr),
                    data :    zeroExtend (x.rs2_val)};
   return y;
endfunction
\end{Verbatim}
}

Lines 6-8 compute the so-called ``Effective Address'' of a LOAD/STORE,
by performing a \emph{signed} addition of the {\tt rs1} and immediate
values.

Line 10 defines the memory-request size (1, 2, 4 or 8 bytes), which in
RISC-V terminology are referred to as Bytes (B), Halfwords (H), Words
(W) and Doublewords (D), respectively).  The {\tt Mem\_Req\_Size} type
is defined in the file {\tt Mem\_Req\_Rsp.bsv} as follows:

{\small
\begin{Verbatim}[frame=single, numbers=left]
typedef enum {MEM_1B, MEM_2B, MEM_4B} Mem_Req_Size
deriving (Eq, FShow, Bits);
\end{Verbatim}
}

Line 10 relies on the fact that these will be coded as 2'b00, 2'b01
and 2'b10, which is exactly the coding found in {\tt instr[13:12]}, so
we can simply ``{\tt unpack}'' the bits to the type {\tt
Mem\_Req\_Size} without any further manipulation.

% ----------------
\hdivider

\Exercise

In Line 10, what if {\tt instr[13:12]} had the value 2'b11?  This is a
legal instruction in the RV64I ISA, for LOADs and STOREs of 8-byte
values, but illegal in RV32I.  Should we check that here?

\emph{Hint:} study the {\tt is\_legal\_LOAD()} {\tt
is\_legal\_STORE()} functions used in the Decode function {\tt
fn\_Decode()} to see if we will ever encounter an illegal value here.

\Exercise

Write a different version of Line 10 that does not rely on the
one-to-one coding equivalence of {\tt instr[13:12]} and the bit coding
of {\tt Mem\_Req\_Size}.

\emph{Hint:} The solution will be a nested if-then-else, or a {\tt
case} expression.

\Endexercise
% ----------------

Here is the function for the second phase, accepting a memory response
as argument and computing the struct to be sent to the Retire step.

{\small
\begin{Verbatim}[frame=single, numbers=left]
function EX_to_Retire fn_DMem_Rsp (Mem_Rsp x);
   Bool exception = ((x.rsp_type == MEM_RSP_ERR)
                     || (x.rsp_type == MEM_RSP_MISALIGNED));
   Bit #(XLEN)  cause = ((x.rsp_type == MEM_RSP_MISALIGNED)
       		      	 ? (is_LOAD (x.instr)
			    ? cause_LOAD_ADDRESS_MISALIGNED
			    : cause_STORE_AMO_ADDRESS_MISALIGNED)
			 : (is_LOAD (x.instr)
                            ? cause_LOAD_ACCESS_FAULT
                            : cause_STORE_AMO_ACCESS_FAULT));

   let y = EX_to_Retire {exception:  exception,
                         cause:      cause,

                         data_valid: (! is_STORE (x.instr)),
                         data:       truncate (x.data)};
   return y;
endfunction
\end{Verbatim}
}

Lines 2-10 convert the memory-systems ``exception'' codes ({\tt
MEM\_RSP\_ERR} and {\tt MEM\_RSP\_MISALIGNED}) into RISC-V {\tt cause}
codes ({\tt cause\_...}).)

Lines 12-16 constructs the required {\tt EX\_to\_Retire} result and
line 17 returns it.

Line 15 uses {\tt (!~is\_STORE())} to indicate whether the {\tt data}
field is valid or not, {\ie} if it is not a STORE, it must be a LOAD,
returning data.  Note that the code may set {\tt data\_valid} to true
when there is an exception in a LOAD, but in that case the {\tt
data\_valid} value does not matter.

% ----------------
\hdivider

\Exercise

When implementing the ``A'' RISC-V ISA Extension (Atomic Memory Ops),
the repertoire of memory operations widens from LOAD and STORE to
include LR (Load-Reserved), SC (Store-Conditional) and a variety of
AMOxxx ops such as AMOADD, AMOSWAP, and so on.
Will line 15's {\tt (!~is\_STORE())} remain adequate, in that case?

\Endexercise
% ----------------

% ****************************************************************

\section{The Retire function}

\label{Sec_Retire_function}

\index{fn\_Retire@{\tt fn\_Retire} (Retire function)}
\index{Retire function ({\tt fn\_Retire})}

As seen in Figure~\ref{Fig_Fetch_function_Simple_Instr_Exec} the
Retire function takes an input of type \verb|RR_to_Retire| from
Register-Read-and-Dispatch (RRD).  This input exists for every
instruction.  Depending on the kind of instruction, it may also
receive an input:

\begin{tightlist}

  \item from Control (of type \verb|Control_to_Retire|), discussed in
    Section~\ref{Sec_Control_function},

  \item from Execute Integer Arithmetic and Logic Ops (EXI, of type
    \verb|EX_to_Retire|), discussed in Section~\ref{Sec_EXI_function},
    or

  \item from Execute Memory Ops (DMem, also of type
    \verb|EX_to_Retire|).

\end{tightlist}

One of the outputs of the Retire function, also called the
\emph{redirection} output, is an indication of the next PC from which
Fetch should resume.  This could be:

\begin{tightlist}

  \item the fall-through PC (the most common case); or

  \item the target PC of a taken BRANCH, or of JAL/JALR; or

  \item the PC of the trap-vector, in case the current instruction had
    an exception; or

  \item the PC of the interrupt handler, in case there is an
    interrupt pending and we choose to handle it now.
\end{tightlist}

This redirection information from the Retire function is carried in
this struct:

{\small
\begin{Verbatim}[frame=single, numbers=left]
typedef struct {
    Bit #(XLEN) next_pc;
} F_from_Retire
deriving (Bits, FShow);
\end{Verbatim}
}

Note, in Fife, the Fetch unit would have predicted the next PC and
already fetched an instruction from that predicted address.  If it
predicted correctly, the Fetch unit does not need to be redirected
from the Retire unit, and we can just discard this information.  We'll
discuss this in more detail when we discuss Fife in later chapters.

A second output from Retire is an indication of a value to be written
back to the GPRs, for those instructions that have an \verb|rd|
destination field and which have completed successfully (without an
exception).

{\small
\begin{Verbatim}[frame=single, numbers=left]
typedef struct {Bool        commit;    // True: write rd
                Bit #(5)    rd;
                Bit #(XLEN) data;
} RW_from_Retire
deriving (Bits, FShow);
\end{Verbatim}
}

The \verb|commit| field tells us whether to write a register or not.
If true, the other two fields specify the register and the value to be
written.

Now we can describe the overall output of Retire, \verb|Result_Retire|:

{\small
\begin{Verbatim}[frame=single, numbers=left]
typedef struct {
   Bool         exception;
   Bit #(XLEN)  cause;
   Bit #(XLEN)  exception_pc;

   F_from_Retire   to_F;
   RW_from_Retire  to_RW;
} Result_Retire
deriving (Bits, FShow);
\end{Verbatim}
}

If there was an exception in this instruction, \verb|exception| is
true, \verb|cause| specifies the kind of exception, and
\verb|exception_pc| is the PC of this instruction, to be saved as
information for the exception handler.  If \verb|exception| is false,
then \verb|to_F| specifies the redirection, and \verb|to_RW| specifies
the optional register-write.

We can now see the Retire function, \verb|fn_Retire|:

{\small
\begin{Verbatim}[frame=single, numbers=left]
function Result_Retire
         fn_Retire (RR_to_Retire         x_RR,
                    Control_to_Retire    x_Control,
                    EX_to_Retire         x_EX);

   Bool         exception    = False;
   Bit #(XLEN)  cause        = ?;
   Bit #(XLEN)  exception_pc = x_RR.pc;
   let          y_to_F       = F_from_Retire {next_pc: ?};
   let          y_to_RW      = RW_from_Retire {commit: False, rd: ?, data: ?};

   // Fill in fields according to the various incoming flows
   if (x_RR.exec_tag == EXEC_TAG_RETIRE) begin
      if (x_RR.exception) begin
         exception = True;
         cause     = x_RR.cause;
      end
      else
         y_to_F.next_pc = x_RR.fallthru_pc;
   end
   else if (x_RR.exec_tag == EXEC_TAG_CONTROL) begin
      if (x_Control.exception) begin
         exception = True;
         cause     = x_Control.cause;
      end
      else begin
         y_to_F.next_pc = x_Control.next_pc;
         y_to_RW.commit = x_Control.data_valid;
         y_to_RW.rd     = instr_rd (x_RR.instr);
         y_to_RW.data   = x_Control.data;
      end
   end
   else begin // exec_tag == EXEC_TAG_IALU/EXEC_TAG_DMEM
      if (x_EX.exception) begin
         exception = True;
         cause     = x_EX.cause;
      end
      else begin
         y_to_F.next_pc = x_RR.fallthru_pc;
         y_to_RW.commit = x_EX.data_valid;
         y_to_RW.rd     = instr_rd (x_RR.instr);
         y_to_RW.data   = x_EX.data;
      end
   end

   // Construct and return final result
   let y = Result_Retire {exception:    exception,
                          cause:        cause,
                          exception_pc: exception_pc,
                          to_F:         y_to_F,
                          to_RW:        y_to_RW};
   return y;
endfunction
\end{Verbatim}
}

The meat of the code is lines 13-44, which is a big if-then-else that
examines the incoming \verb|x_RR.exec_tag| and the various exception
fields \verb|x_RR.exception|, \verb|x_Control.exception| and
\verb|x_EX.exception| to decide how to fill in the output struct
fields.

% ----------------
\hdivider

\Exercise

In line 33 (the final \verb|else| clause) we have a comment asserting
that \verb|exec_tag| must be \verb|EXEC_TAG_IALU| or
\verb|EXEC_TAG_DMEM|.  Prove this assertion by reasoning forward from
the Register-Read-and-Dispatch function \verb|fn_RR|.

\Endexercise
% ----------------

% ****************************************************************
