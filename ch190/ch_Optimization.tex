% -*- mode: fundamental -*-

% ****************************************************************

\chapter{RISC-V: Optimization of Drum and Fife}

\markboth{Ch \arabic{chapter}: RISC-V: Optimization}{\copyrightnotice}

\setcounter{page}{1}
% \renewcommand{\thepage}{\arabic{page}}
\renewcommand{\thepage}{\arabic{chapter}-\arabic{page}}

\label{ch_Optimization}

% ****************************************************************

% ----------------
\vspace{2ex}

\centerline{\includegraphics[width=1in,angle=0]{Figures/Fig_Under_Construction}}

\vspace{2ex}
% ----------------

% ****************************************************************

\section{Introduction}

All of these are potential exercises

Many of the techniques described in the previous sections (including
Tandem Verification) only verify \emph{functional correctness}, {\ie}
they address the question: does running the program on the
implementation produce the ``correct'' answer(s)''?

For CPUs implementations, of course, we are also equally interested in
verifying how \emph{fast} they run: does it produce the answer(s) in
the expected time?

Ultimately what matters is application performance, not clock speed.
Application performance is a product of clock speed (cycles/second)
and instructions/cycle.  These have to be simultaneously optimized for
the best product.  They are not independent; higher clock speeds
restrict how much ``circuit work'' can be done in a single clock
which, in turn, affects microarchitecture, which can affect
instructions/cycle.

Instructions/cycle depends on microarchitecture.  The more parallelism
we can exploit, the more instructions/cycle.  Compare Drum
(unpipelined) vs. Fife (pipelined)

Wasted clocks due to misprediction.

Wasted clocks due to hazard penalty.

Wasted clocks due to cache misses.

Power consumption.

% ================================================================

\subsection{Pipeline visualisation}

TO BE WRITTEN

% ****************************************************************

\section{Drum: Fusing Decode and RR-Dispatch, fusing some Retire actions}

% ****************************************************************

\section{Fife: Dispatching multiple instructions that write to the same Rd}

\begin{itemize}
 \item Scoreboard bits can can be a small up-down counter, not just Bool
 \item In RR, increment Rd and allow instr to go. Stall if rs1/rs2's counter is not zero.
 \item Current 1-bit is essentially a 1-bit counter.
\end{itemize}

% ****************************************************************

\section{Bypassing: Save a cycle for Redirect in Fetch PC/epoch update}

% ****************************************************************

\section{Bypassing: Save a cycle for in GPRs and Scoreboard for {\tt update\_rd}}

% ****************************************************************

\section{Saving a cycle in Fife by jamming-together Decode and RR-Dispatch}

% ****************************************************************

\section{Saving cycles in Fife Retire by merging exception-handling into other rules}

% ****************************************************************

\section{Saving FIFO resourced in Fife by jamming-together mkPipelineFIFOF and mkBypassFIFOF}

% ****************************************************************
